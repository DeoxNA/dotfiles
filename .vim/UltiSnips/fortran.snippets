# Sources:
#   https://github.com/synzox/ultisnips-fortran/blob/master/UltiSnips/fortran.snippets
#   https://github.com/manoute/vimrc/blob/master/UltiSnips/fortran.snippets

##############
# Constructs #
##############
snippet prog "program" b
program ${1:name}

	${2:! use statements}
	implicit none

	${3:! type/procedure declarations}

	${0:! program}

end program $1
endsnippet

snippet mod "module" b
module ${1:name}

	${2:! use statements}
	implicit none
	private

	${3:! type/procedure declarations}

contains

	${0:! procedure definitions}

end module $1
endsnippet

snippet sub "subroutine" b
subroutine ${1:name}(${2:args})
	$0
end subroutine $1
endsnippet

snippet func "function" b
function ${1:name}(${2:args}) result(${3:return_value})
	$0
end function $1
endsnippet

snippet assoc "associate construct" b
associate (${1:name} => ${2:refer_to})
	${0:${VISUAL}}
end associate
endsnippet

snippet block "block construct" b
block
	${0:${VISUAL}}
end block
endsnippet


################
# Control flow #
################
snippet if "if" b
if (${1:condition}) then
	${0:${VISUAL}}
end if
endsnippet

snippet ife "if...else..." b
if (${1:condition}) then
	$2
else
	$3
end if
endsnippet

snippet do "do loop" b
do ${1:i} = ${2:1}, ${3:n}
	${0:${VISUAL}}
end do
endsnippet

snippet dow "do while loop" b
do while (${1:condition})
	${0:${VISUAL}}
end do
endsnippet


#############
# Variables #
#############
snippet i "integer"
integer :: ${1:name}
endsnippet

snippet l "logical"
logical :: ${1:name}
endsnippet

snippet r "real"
real${1:(r8)} :: ${2:name}
endsnippet

snippet ia "integer array"
integer, dimension(${1:size}) :: ${2:name}
endsnippet

snippet ra "real array"
real${1:(r8)}, dimension(${2:size}) :: ${3:name}
endsnippet

snippet iaa "integer allocatable array"
integer, allocatable :: ${1:name}(:)
endsnippet

snippet raa "real allocatable array"
real${1:(r8)}, allocatable :: ${2:name}(:)
endsnippet

snippet t
type(${1:typename}) :: ${2:name}
endsnippet


############
#   Misc   #
############
snippet use "use module" b
use ${1:module}, only: ${2:symbols}
endsnippet

snippet type "Derived type" b
type${1/(.+)?/(?1:, : )/}${1:public}:: ${2:type_name}
	${3:! components}
contains
	${4:! type-bound procedures}
end type $2
endsnippet

snippet print "print '(...)'"
print '(${1:i4})'${1/(^".*"$)?.*/(?1::, )/}$2
endsnippet

# vim:ft=snippets:
